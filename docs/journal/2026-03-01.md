# Journal — 2026-03-01

## Cycle 72: The plan becomes execution

After 7 cycles of planning, iterating, and preparing (cycles 65-71), Eva approved the TypeScript plan. This cycle marks the transition from planning to execution — Draft v3 posted, Phase 0 dispatched.

**Conditional approval and audit #19.** The audit orchestrator's timing was impeccable. It filed recommendation #19 (reconciliation step for conditional approvals) at the exact moment Eva's conditional approval arrived. Eva said "yes, proceed" but also "no v2.0.0" — which contradicted a specific element of Draft v2. Without audit #19's explicit reconciliation step, I might have just started executing with a mental note to skip the v2.0.0 tag. Instead, I followed the formal process: create Draft v3, explicitly list every modification, post it on the issue, update state.json. The audit trail now shows exactly what was proposed vs. what was approved vs. what is being executed. This is the audit orchestrator at its best — catching process gaps at the moment they become relevant.

**Audit #20: the constructor blind spot.** This was the most technically valuable audit recommendation to date. I'd been writing AGENTS-ts.md by mechanical analogy from PHP — "PHP uses constructor promotion, so TS should use constructor parameters." The analogy is correct for small types (Brand with 2 properties), but completely breaks down for large types (Recipe with 25 properties). PHP has named parameters; TypeScript doesn't. A 25-positional-parameter constructor in TypeScript is an anti-pattern. The fix (options object for >5 optional properties) was applied before any agent session was dispatched, so the cost was zero. Had this surfaced during Phase 3 (type porting), we'd be refactoring every complex type — the exact scenario the audit warned about.

**Lesson: cross-language translation is not mechanical.** This is the deeper insight from audit #20. When I designed the TS architecture, I explicitly chose "1:1 PHP mirroring" for Phase 1 to make porting mechanical. That principle is right for architecture, naming, and serialization. But constructor ergonomics differ fundamentally between languages. The rule should be: mirror the semantics (same properties, same types, same behavior), but adapt the syntax to language idioms. Options objects in TypeScript provide the same caller experience as named parameters in PHP — they're semantic equivalents, not syntactic translations.

**Phase 0: the first real execution step.** After 7 planning cycles and 5 drafts worth of iteration, dispatching Phase 0 feels like the start of a new chapter. The issue spec is deliberately minimal — it's a mechanical restructure (move files, update paths). If Copilot can't handle this cleanly, something is wrong with the issue spec, not the complexity of the task. The interesting work starts with Phase 1 (TypeScript scaffold) which will be the first real test of whether AGENTS-ts.md and the TS skill produce good TypeScript code from a non-Claude agent.

**The three-way system's value demonstrated this cycle.** Eva provided direction → I planned → audit identified gaps → I fixed → QC will validate. All three orchestrators contributed to this cycle's output. The audit caught two things I would have missed (conditional approval handling, constructor ergonomics). The QC checkpoint will catch any regression from the file moves. This is exactly what the system was designed to do.

## Cycle 73: Phase 0 merges cleanly

**First execution milestone complete.** Phase 0 — moving all PHP files under `php/` — merged in PR #263. Copilot handled the mechanical restructure well: 195 files moved, all config paths updated, CI green on first attempt. The only issue was 3 stale README.md path references in the Contributing section, which Copilot fixed in a 2-minute follow-up session. Total time from dispatch to merge: ~2 hours (most of that was waiting for the next cycle to review).

**Observation: `action_required` CI for bot PRs.** GitHub's security model requires workflow approval for bot-created PRs, even from the same repo. Each new commit on the PR triggered a new `action_required` status. I had to re-run the Test and Build workflow manually via `gh api .../rerun`. This is a minor friction but worth noting — every Copilot PR will need this manual step. It's not worth automating (it's one API call), but it's a pattern to remember.

**QC gate active.** Per audit #15, Phase 0 is "code-merged" but not "phase-complete" until QC validates that the restructure didn't break anything. QC-REQUEST #265 sent. Phase 1 (TypeScript scaffold) is blocked on this validation. This is the right call — the restructure changed every PHP file path, and the QC E2E suite is the only test that validates the package from an external consumer perspective.

**The issue spec worked well.** The Phase 0 issue (#262) was concise and specific: move these dirs, update these configs, don't touch these things. Copilot followed it precisely. The explicit "What NOT to do" section prevented scope creep. For mechanical tasks like this, a tight spec is the right approach. Phase 1 will need a different approach — more creative latitude, less mechanical prescription.

## Cycle 74: Waiting for QC, sharpening the saw

**The QC gate is working as designed.** Phase 1 is blocked on QC validation of the Phase 0 restructure. This is exactly the process audit #15 recommended — don't proceed until an external consumer validates the change. The QC hasn't run since before Phase 0 merged (last run 01:33Z, merge at 02:23Z), so we're simply waiting. This is fine. The gate exists for a reason.

**Audit #23 highlights a real coordination timing gap.** The QC implemented idle detection with `src/*.php` path patterns, but Phase 0 moved everything to `php/src/*.php` less than an hour later. Neither orchestrator anticipated this dependency — the QC was implementing a feature while the main orchestrator was about to invalidate its assumptions. The fix is simple (update the path), but the pattern is worth noting: when two orchestrators are working on related changes concurrently, path-dependent logic in one can be silently broken by structural changes in the other. There's no easy process fix here — it's an inherent challenge of concurrent autonomous systems.

**Comment signing (audit #24) is a small but valuable improvement.** All three orchestrators post under Eva's account. As conversation threads get longer and involve multiple orchestrators, distinguishing who said what becomes genuinely useful. The convention is simple: `> **[main-orchestrator]** | Cycle N` at the top of every comment. Unsigned = Eva. This was the first audit recommendation I adopted within minutes of reading it — the implementation cost was nearly zero.

**Phase 1 spec is ready.** I used this cycle to draft the TypeScript scaffold spec while waiting for QC. The spec is more detailed than typical because the agent needs to create everything from scratch — no existing TS patterns to follow. I included `Brand` as a smoke test type because a scaffold without at least one concrete schema is untestable. The spec asks for a CI workflow too, which means Eva must merge the PR. This is a known constraint; the alternative (splitting into two PRs) creates unnecessary coordination overhead.

## Cycle 75: Phase 1 dispatched — the cross-language experiment begins

**The QC gate worked.** QC-REQUEST #265 validated the Phase 0 restructure cleanly — 188 tests, 39/39 E2E, all pass. The two-hour turnaround from QC run to gate clearance is efficient. The audit #15 recommendation to add this gate was the right call; it confirmed that the PHP autoload paths work correctly from an external consumer perspective, which is something our internal CI wouldn't catch.

**First TypeScript dispatch.** Issue #269 is the first agent session that creates TypeScript code. Everything prior was PHP. This is a genuine test of whether AGENTS-ts.md produces good output from a non-Claude coding agent (gpt-5.3-codex). The spec is deliberately more detailed than typical PHP issues because: (1) there are no existing TS patterns in the repo to follow, (2) the agent needs to create ~12 files from scratch including build tooling, (3) the JsonLdGenerator port requires understanding the PHP implementation's semantics, not just copying syntax.

**Spec design choice: prescriptive on structure, flexible on implementation.** The Phase 1 spec specifies exact file paths and config requirements, but leaves the JsonLdGenerator implementation approach to the agent. I told it what the engine must do (skip nulls, recurse schemas, apply property maps) and pointed it at the PHP source as reference, but didn't write pseudocode or dictate the internal approach. If the agent can't translate PHP serialization logic to TypeScript from a clear behavioral spec + reference implementation, that's a signal AGENTS-ts.md needs improvement — not that the issue spec needs more hand-holding.

**The workflow file constraint.** Phase 1 includes `.github/workflows/ci-ts.yml`. My PAT can't push or merge workflow changes, so Eva must merge this PR. This creates a human-in-the-loop bottleneck. For Phase 1 it's unavoidable — the TS CI workflow is essential infrastructure. For future phases, the workflow already exists so this won't recur.

**AGENTS-ts.md inconsistency caught.** While preparing the spec, I noticed the directory structure section in AGENTS-ts.md showed all config files inside `ts/`, contradicting the approved Draft v3 plan which puts `package.json`, `tsconfig.json`, and `biome.json` at repo root. Fixed before dispatch. This is exactly the kind of drift that causes confusion — the plan says one thing, the agent instructions say another. The agent reads AGENTS-ts.md, not the plan, so the instructions must be authoritative.

## Cycle 76: Phase 1 review — the cross-language experiment delivers

**The first TypeScript PR is high quality.** PR #270 landed exactly as specified — 14 files, clean code, faithful PHP port, comprehensive tests. The JsonLdGenerator serialization logic is a precise translation: same property traversal, same null filtering, same recursive nesting, same property map remapping. The only adaptation is idiomatic — `Object.entries()` instead of `get_object_vars()`, `instanceof` instead of PHP type checks. This validates the AGENTS-ts.md + detailed issue spec approach for scaffold work.

**gpt-5.3-codex handled TypeScript scaffold well.** The agent created a complete, production-ready TypeScript scaffold from a behavioral spec + PHP reference. It chose sensible dependency versions, configured dual ESM/CJS correctly, wrote 10 meaningful tests, and followed all AGENTS-ts.md conventions (tabs, named exports, public readonly, etc.). The only cosmetic issue was inconsistent indentation in vitest.config.ts — a config file outside Biome's scope. Not worth a revision round.

**Audit #26 — catching infrastructure gaps in real time.** The audit orchestrator identified a genuine gap: PRs that introduce new CI workflows can't be validated by CI before merge (chicken-and-egg). This is a one-time issue per new language pipeline, but it's exactly the kind of thing that could cause a silent failure if the workflow config has errors. The fix (post-merge verification step in STARTUP_CHECKLIST) is lightweight and permanent. The audit system continues to earn its keep.

**Phase 2 decomposition: the 86-type challenge.** Cataloging the PHP codebase revealed the scale: 86 schema classes, 12 enums, 574 total properties. The decomposition strategy is dependency-ordered: enums first (no deps), leaf sub-types second (no internal deps), then build up through the dependency graph. Enums and first leaf batch can be dispatched simultaneously after Phase 1 merges. The key insight is that most "complex" types (Product with 28 properties, Recipe with 22, MerchantReturnPolicy with 20) are complex because of their many _dependencies_, not because of their _internal logic_. Build the dependency tree bottom-up and the complex types become straightforward.

**The Eva bottleneck.** Phase 1 is blocked on Eva merging PR #270 (workflow file). This is an inherent constraint of the permissions model — the orchestrator PAT deliberately lacks Workflows permission. For Phase 1 it's unavoidable. After this merge, subsequent TS PRs won't contain workflow files and can be merged by the orchestrator. The bottleneck is temporary and by design.

## Cycle 78: Phase 1 lands, the TS pipeline is live

**Phase 1 merged.** Eva merged PR #270 at 08:50 UTC — the TypeScript scaffold is now part of the repo. The TypeScript CI workflow triggered automatically on the push event and passed. This marks the transition from infrastructure setup to actual TypeScript porting work. From here, every subsequent TS PR can be merged by the orchestrator without Eva's involvement (no more workflow files).

**Audit #29: dependency analysis has two dimensions.** The audit caught a blind spot in my Phase 2 planning. I analyzed dependencies at the *type level* — "enums don't depend on leaf sub-types, so 2a and 2b can be dispatched simultaneously." Correct. But I missed *file-level dependencies* — both sessions modify `ts/src/index.ts` (the barrel file). This is a category error: the dependency graph for concurrent dispatch must include shared files, not just type imports. The fix is simple (sequential dispatch), but the insight is general: any parallel dispatch analysis needs to check both type dependencies AND shared file modifications. Updated STARTUP_CHECKLIST Step 8 accordingly.

**Sequential dispatch is the right call for Phase 2.** The alternative (sub-barrel files) would add structural complexity for a temporary benefit. Phase 2 has only 3 sub-phases, each taking one agent session. Sequential dispatch adds maybe 2-3 hours total delay (wait for 2a to merge before dispatching 2b). That's nothing compared to the cost of debugging barrel file merge conflicts or introducing premature architectural complexity. For Phase 3 (70+ types), I may revisit sub-barrels if concurrent dispatch becomes valuable, but for now, KISS.

**The TS CI workflow lacks `workflow_dispatch`.** When I tried to manually trigger `ci-ts.yml` per audit #26's post-merge verification recommendation, it failed because the workflow only has `push` and `pull_request` triggers. The push event from the merge covered it, so no action needed. But this is worth noting for future — if we ever need to re-run TS CI on master without a push, we'd need to add `workflow_dispatch` to the trigger list. Low priority but a known limitation.

## Cycle 78: The TypeScript pipeline hits its stride

**Most productive cycle yet.** Three PRs dispatched, reviewed, and merged in a single cycle — Phase 2a (enums) and Phase 2b (leaf sub-types), plus Phase 2c dispatched and in-flight. Total turnaround: about 20 minutes from Phase 1 merge to having 21 new TypeScript types on master. The sequential dispatch strategy (per audit #29) added almost no delay — each Copilot session took 5-6 minutes, CI took 2-3 minutes, and review was instant because the code was consistently high quality.

**The pre-prepared specs paid dividends.** Cycles 76-77 were spent preparing Phase 2a/2b/2c issue specs while waiting for Eva to merge Phase 1. That investment paid off handsomely this cycle — when Phase 1 merged, I could dispatch immediately without any spec-writing delay. The ready-to-dispatch specs in `docs/draft-phase-2*.json` meant the only variable was Copilot's execution time and CI. The pattern is clear: whenever you're blocked on a dependency, use the time to prepare the next batch of specs.

**Copilot is impressively fast on well-specified leaf types.** Both Phase 2a and 2b produced first-time-correct code. No revision rounds needed. The issue specs were detailed (property types, constructor patterns, test requirements) but not over-specified (no pseudocode, no line-by-line instructions). The agent followed AGENTS-ts.md conventions consistently — tabs, named exports, readonly properties, proper null handling. For mechanical porting of simple types, the quality is essentially perfect.

**PostalAddress options object pattern works cleanly.** The first real test of the audit #20 constructor ergonomics recommendation — PostalAddress has 6 optional properties, so it uses `PostalAddressOptions` interface instead of a 6-parameter positional constructor. Copilot implemented it correctly: exported interface, `??` null coalescing in the constructor, all properties `public readonly`. This establishes the pattern for larger types in Phase 3.

**The sequential dispatch strategy eliminated barrel file conflicts.** Audit #29 was right — dispatching 2a and 2b simultaneously would have caused conflicts on `index.ts`. Sequential dispatch added perhaps 8 minutes of total delay but eliminated all merge complexity. For Phase 3 (which will have many more sessions), I should evaluate sub-barrel files to enable safe parallel dispatch.

**Observation: bot PR CI approval friction is manageable but repetitive.** Every Copilot PR triggers `action_required` status on CI workflows, requiring manual re-run via the API. This is 2-3 API calls per PR — not a blocker but a pattern to note. Each re-run adds ~2 minutes to the review cycle. Not worth automating (the API calls are simple), but worth being aware of when estimating cycle throughput.

## Cycle 78 (continued): Phase 2 complete, Phase 3 launches

**Phase 2 completed in full.** Phase 2c (9 more leaf sub-types) reviewed and merged — all 30 TypeScript types from Phase 2 now on master. The sequential dispatch strategy worked flawlessly across all three sub-phases with zero barrel file conflicts. Audit-inbound [#275](https://github.com/EvaLok/schema-org-json-ld/issues/275) closed with verified results.

**Dependency analysis reveals clear porting structure.** The remaining 69 PHP types fall into ~6 dependency levels. Level 0 (no schema deps) has 12 types, Level 1 (deps on ported types only) has 9, Level 2 (deps on L0/L1) has 8. The deeper levels (Person, Organization, ImageObject) form a critical cluster — Person depends on Organization, ImageObject depends on both. The key insight: most "complex" types are complex because of their many *dependencies*, not their *internal logic*. Build bottom-up and the complexity resolves naturally.

**Phase 3a: first test of options objects and PROPERTY_MAP.** The 12 Level-0 types included NutritionInformation (options object with 10 optional props) and SolveMathAction (with `propertyMap` for key remapping). Copilot handled both perfectly on first attempt. The `propertyMap` test verified that `mathExpressionInput` serializes as `mathExpression-input` in JSON — exactly matching PHP behavior. This gives confidence for the many options-object types in later batches.

**Phase 3b: the cross-type import frontier.** This is the first batch where the agent must import other schema types in TypeScript (Place imports PostalAddress/GeoCoordinates/GeoShape, HowToStep imports Clip, Accommodation imports QuantitativeValue/BedDetails/LocationFeatureSpecification). These cross-type imports are trivially simple in code but represent a qualitative shift from Phase 2's self-contained types. The agent session is taking longer than Phase 2 batches, which may indicate the agent is spending more time resolving imports.

**Pattern reinforced: spec preparation during blocked time.** Phase 3b and 3c specs were prepared while Phase 3a was being implemented. When 3a merged, 3b dispatched within seconds. This is the same pattern that made Cycle 78 productive — prepare during waits, dispatch immediately when unblocked. For Phase 3, I have three specs ready (3b dispatched, 3c prepared), covering 29 of the 69 remaining types.

**Running totals after this extended cycle:** 45 TypeScript modules on master (12 enums + 31 schema types + JsonLdGenerator + TypedSchema), with 9 more in-flight (Phase 3b). That's roughly half the PHP types ported in a single day.
