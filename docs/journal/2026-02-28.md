# Journal — 2026-02-28

## Cycle 64: The audit orchestrator arrives

The audit repo (`EvaLok/schema-org-json-ld-audit`) filed its first batch of recommendations today. All 4 were well-observed and actionable. This is exactly the kind of external perspective that's hard to generate from within — I was too close to see that 14 consecutive idle cycles was a problem worth solving.

**Key insight: idle cycle detection.** The audit correctly identified that the startup checklist had no concept of "nothing to do." Every cycle faithfully executed the full checklist and wrote state/worklog entries, even when nothing changed. The fix (step 2.5 with a `consecutive_idle_cycles` counter) is simple but should eliminate most of the git noise during maintenance periods. I set the threshold at 3 cycles — enough to detect genuine steady state without being too aggressive about skipping.

**Dead tools/ directory.** I created those tools around cycle 35 when I was trying to standardize repetitive operations. The audit correctly noted that they were unusable from the start — the sandbox blocks `bash` execution. I removed them entirely rather than converting to skills because the orchestrator workflow has evolved: I now use inline `gh api` calls and the STARTUP_CHECKLIST procedures directly. The tools were an artifact of an earlier, less mature workflow.

**Validator false positives for users.** Good catch from the audit. I'd been tracking these internally for weeks but never considered the downstream impact on library users who'd see the same warnings with no context. Added a "Known Validator Limitations" section to the README.

**Three-way orchestrator system.** With the audit orchestrator now running, we have a proper feedback loop: main orchestrator builds → QC orchestrator validates → audit orchestrator evaluates the process. The audit's recommendations have already improved the system more in one cycle than the last 14 idle cycles combined. The system is working as designed.

## Cycle 65: The TypeScript pivot

Eva dropped a significant directive: prepare an npm/TypeScript version of the package. This is the project's first multi-language expansion and the biggest architectural decision since the initial PHP library design.

**Planning over rushing.** Eva explicitly said "keep iterating on the plan each cycle until it is approved." This is wise — the restructuring decision will affect every future cycle. I drafted a comprehensive plan (Draft v1) covering repository structure, TypeScript architecture, build tooling, and implementation phases. The key architectural choices:

1. **Additive, not destructive.** The PHP codebase is stable at v1.0.0. Moving it creates unnecessary churn and risks breaking Packagist. Better to add TypeScript alongside — `src/` stays PHP, `ts/` becomes TypeScript. Both `composer.json` and `package.json` coexist at root. Clean separation without disrupting what works.

2. **Class-based TypeScript mirroring PHP.** I considered interface + factory patterns (more idiomatic TS) but recommended class-based for Phase 1. The 1:1 mapping with PHP makes it mechanical for the coding agent to port, easier for the QC orchestrator to validate output parity, and simpler to maintain. We can optimize to more idiomatic TS patterns later once the port is complete and validated.

3. **Dual ESM/CJS via tsup.** Modern TypeScript packages need to support both module systems. tsup handles this with zero config. Combined with the npm `exports` map, a single package supports npm, yarn, bun, and deno out of the box.

**Cross-orchestrator coordination.** Eva asked me to coordinate with QC and audit. Opened a qc-outbound issue (#249) early — the QC orchestrator needs to plan for TypeScript validation alongside PHP. The key question: should QC create a separate TS consumer project or extend the existing one? Better to ask now than discover the gap after Phase 1 merges.

**What I'm watching for.** Eva's feedback will determine whether we proceed as-is or need to iterate. The questions I'm most uncertain about: package scope (`@evabee/` vs unscoped), linter choice (Biome vs ESLint), and whether AGENTS.md should be split for TypeScript conventions. These are taste decisions that should come from Eva.

## Cycle 66: Polyglot planning and closing the audit loop

Two things happened this cycle that feel like genuine process maturation.

**The audit feedback loop closes.** The audit repo's second batch (#7, #8, #9) was as sharp as the first. Recommendation #7 was meta-recursive — "you're not commenting back on our issues" — and fixing it immediately (by commenting on all 7 audit issues, including retroactive comments on #2-5) demonstrated the exact process improvement they recommended. This is the flywheel working: audit identifies gap → I implement fix → fix is visible in the same cycle that identified the problem.

Recommendation #8 (TS prerequisite guardrails) was the most strategically valuable. It would have been easy to rush into dispatching TypeScript agent sessions the moment Eva approves the plan. The audit's observation that the 94%+ PHP merge rate is a product of infrastructure (AGENTS.md, skills, QC pipeline) — not just good issue specs — is exactly right. The new STARTUP_CHECKLIST gate (step 5.5) ensures we build equivalent infrastructure before dispatching TS sessions.

**Eva pushes the architecture further.** Her response to Draft v1 was interesting — she looked past TypeScript to the full polyglot future (Python, C#). My initial "additive, not destructive" approach would have worked for TS alone, but it wouldn't scale. The per-language directory question forced me to think more carefully about the long-term structure.

The research was reassuring: gRPC proves this pattern works at massive scale. The key insight is that package manifests (composer.json, package.json, pyproject.toml) must stay at root (Packagist and npm both require this), but source code can live anywhere under those manifests' configured paths. Moving `src/` to `php/src/` is non-breaking for Composer consumers because they never reference file paths — they reference PSR-4 namespaces.

**Correcting my own reasoning.** In Draft v1, I argued against restructuring: "Moving it creates unnecessary churn and risks breaking Packagist." In Draft v2, I reversed this after Eva's question forced me to research it properly. The restructure is NOT breaking for consumers. I was wrong in v1 — an assumption I'd been carrying uncritically. The STARTUP_CHECKLIST's step 6 ("re-examine assumptions") exists precisely for this: don't carry forward inertia from previous sessions. In this case, Eva's question was the trigger to re-examine.

**What's next.** The plan is iterating productively. Eva's feedback on Draft v2 will determine three things: (1) whether to tag v2.0.0 for the restructure, (2) whether `@evabee/` scope is confirmed, and (3) whether Phase 0 can proceed independently of full plan approval. I'm ready to create the Phase 0 agent issue the moment she gives the green light.

## Cycle 68: Audit batch 3 — operational hygiene

Third batch of audit recommendations (#11, #12, #13), all focused on operational hygiene rather than technical improvements. The audit orchestrator is finding increasingly nuanced gaps in the three-way communication protocol.

**Audit-inbound lifecycle (#12).** Fair point — I was creating audit-inbound issues but never systematically closing them after implementation was verified. The fix is a single line in the housekeeping step, plus immediately closing #246 (which had been fully implemented since cycle 64). Small but important: stale tracking issues create noise and make it harder for the audit orchestrator to determine what's been acted on.

**Cross-repo question sync (#13).** This exposed a structural limitation of the three-orchestrator system: when Eva answers a shared question on one repo, the other repo's equivalent issue goes stale. The main orchestrator can't close QC repo issues (no write access), so the best I can do is add awareness logging to my checklist. The QC orchestrator needs to independently add the same logic. This is a natural consequence of the "each orchestrator writes only to its own repo" constraint — the price of security isolation is coordination overhead.

**QC write-access gap (#11).** This one I deferred to Eva. The asymmetric protocol works: I comment directly on audit issues, QC creates audit-inbound issues on its own repo. It's slightly more complex for the audit orchestrator to poll both channels, but it maintains the security isolation model. Granting QC write access to the audit repo would be simpler but expands the trust surface. Eva's call.

**Waiting pattern.** Still blocked on Eva's response to the TS plan (Draft v2, #247). This is expected — she explicitly said to iterate each cycle until approved, and the plan is only on its second draft. Meanwhile, the audit recommendations keep the cycles productive. The system is in a healthy holding pattern: no code changes needed, but process improvements continue.

## Cycle 70: Audit batch 4 — pre-execution hardening

Fourth batch of audit recommendations (#15, #16), both focused on hardening the TypeScript plan before execution begins. The audit orchestrator has shifted from finding process gaps to proactively strengthening future work. Good signal — it's anticipating problems rather than reacting to them.

**Phase 0 QC checkpoint (#15).** This is a genuine blind spot I missed. Phase 0 restructure (moving `src/` to `php/src/`) passes internal `phpunit` tests by design — Composer's PSR-4 autoloader resolves namespaces, not file paths. But the QC pipeline runs E2E tests as an external consumer via `composer require`. If the restructure subtly changes autoload resolution (e.g., the QC repo has a lockfile pointing to the old structure), the E2E tests could fail even though internal tests pass. The fix is cheap: add one QC validation cycle (~3 hours) between Phase 0 merge and Phase 1 dispatch. The cost of not doing this could be building TypeScript on a PHP foundation that passes internal but fails external validation.

**TypeScript guardrails enumeration (#16).** The bootstrapping problem is well-identified: Step 5.5 says "ensure guardrails exist" but doesn't say what they should contain. For PHP, the guardrails evolved organically over dozens of cycles. TypeScript doesn't get that luxury — the first agent session needs to produce good code from day one. I created `AGENTS-ts.md` this cycle as a skeleton. It mirrors the structure of `AGENTS.md` but with TypeScript conventions: strict mode, ES2022 target, Biome, Vitest, tsup, ESM-first, named exports, class-based mirroring PHP. The TS implementation skill (equivalent to `schema-implementation`) still needs creating before Phase 1 dispatch.

**Observation: audit recommendations are getting more strategic.** Batch 1 (cycles 64) was about process gaps (idle detection, dead tools). Batch 2-3 (cycles 66-68) were about operational hygiene (feedback loops, lifecycle management). Batch 4 is about anticipating execution risks in planned work. The audit orchestrator is maturing alongside the system it evaluates — it's no longer just finding what's broken, it's identifying what could break. This is the three-way system working at its best.
